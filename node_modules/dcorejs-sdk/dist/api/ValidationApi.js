"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var operators_1 = require("rxjs/operators");
var DCoreConstants_1 = require("../DCoreConstants");
var BaseOperation_1 = require("../models/operation/BaseOperation");
var EmptyOperation_1 = require("../models/operation/EmptyOperation");
var OperationType_1 = require("../models/operation/OperationType");
var GetPotentialSignatures_1 = require("../net/models/request/GetPotentialSignatures");
var GetRequiredFees_1 = require("../net/models/request/GetRequiredFees");
var GetRequiredSignatures_1 = require("../net/models/request/GetRequiredSignatures");
var ValidateTransaction_1 = require("../net/models/request/ValidateTransaction");
var VerifyAccountAuthority_1 = require("../net/models/request/VerifyAccountAuthority");
var VerifyAuthority_1 = require("../net/models/request/VerifyAuthority");
var Utils_1 = require("../utils/Utils");
var BaseApi_1 = require("./BaseApi");
var ValidationApi = /** @class */ (function (_super) {
    __extends(ValidationApi, _super);
    function ValidationApi(api) {
        return _super.call(this, api) || this;
    }
    /**
     * This API will take a partially signed transaction and a set of public keys that the owner has the ability to sign for
     * and return the minimal subset of public keys that should add signatures to the transaction.
     *
     * @param transaction partially signed transaction
     * @param keys available owner public keys
     *
     * @return public keys that should add signatures
     */
    ValidationApi.prototype.getRequiredSignatures = function (transaction, keys) {
        return this.request(new GetRequiredSignatures_1.GetRequiredSignatures(transaction, keys));
    };
    /**
     * This method will return the set of all public keys that could possibly sign for a given transaction.
     * This call can be used by wallets to filter their set of public keys to just the relevant subset prior to calling get_required_signatures() to get the minimum subset.
     *
     * @param transaction unsigned transaction
     *
     * @return public keys that can sign transaction
     */
    ValidationApi.prototype.getPotentialSignatures = function (transaction) {
        return this.request(new GetPotentialSignatures_1.GetPotentialSignatures(transaction));
    };
    /**
     * Verifies required signatures of a transaction.
     *
     * @param transaction signed transaction to verify
     *
     * @return if the transaction has all of the required signatures
     */
    ValidationApi.prototype.verifyAuthority = function (transaction) {
        return this.request(new VerifyAuthority_1.VerifyAuthority(transaction));
    };
    /**
     * Verifies if the signers have enough authority to authorize an account.
     *
     * @param nameOrId account name or object id
     * @param keys signer keys
     *
     * @return if the signers have enough authority
     */
    ValidationApi.prototype.verifyAccountAuthority = function (nameOrId, keys) {
        return this.request(new VerifyAccountAuthority_1.VerifyAccountAuthority(nameOrId, keys));
    };
    /**
     * Validates a transaction against the current state without broadcasting it on the network.
     *
     * @param transaction signed transaction
     *
     * @return {@link ProcessedTransaction} or fails with {@link DCoreError}
     */
    ValidationApi.prototype.validateTransaction = function (transaction) {
        return this.request(new ValidateTransaction_1.ValidateTransaction(transaction));
    };
    /**
     * Returns fees for operation.
     *
     * @param op list of operations
     * @param assetId asset id eg. DCT id is 1.3.0
     *
     * @return a list of fee asset amounts
     */
    ValidationApi.prototype.getFees = function (op, assetId) {
        if (assetId === void 0) { assetId = DCoreConstants_1.DCoreConstants.DCT_ASSET_ID; }
        return this.request(new GetRequiredFees_1.GetRequiredFees(op, assetId));
    };
    ValidationApi.prototype.getFee = function (op, assetId) {
        if (assetId === void 0) { assetId = DCoreConstants_1.DCoreConstants.DCT_ASSET_ID; }
        if (op instanceof BaseOperation_1.BaseOperation) {
            return this.getFees([op], assetId).pipe(operators_1.map(function (fee) { return fee[0]; }));
        }
        else {
            Utils_1.assertThrow([
                OperationType_1.OperationType.ProposalCreate,
                OperationType_1.OperationType.ProposalUpdate,
                OperationType_1.OperationType.WithdrawPermissionClaim,
                OperationType_1.OperationType.Custom,
            ].indexOf(op) === -1);
            return this.getFee(new EmptyOperation_1.EmptyOperation(op), assetId);
        }
    };
    return ValidationApi;
}(BaseApi_1.BaseApi));
exports.ValidationApi = ValidationApi;
//# sourceMappingURL=ValidationApi.js.map