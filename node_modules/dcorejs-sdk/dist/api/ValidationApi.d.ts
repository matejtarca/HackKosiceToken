import { Observable } from "rxjs";
import { Address } from "../crypto/Address";
import { DCoreApi } from "../DCoreApi";
import { AssetAmount } from "../models/AssetAmount";
import { ChainObject } from "../models/ChainObject";
import { BaseOperation } from "../models/operation/BaseOperation";
import { OperationType } from "../models/operation/OperationType";
import { ProcessedTransaction } from "../models/ProcessedTransaction";
import { Transaction } from "../models/Transaction";
import { BaseApi } from "./BaseApi";
export declare class ValidationApi extends BaseApi {
    constructor(api: DCoreApi);
    /**
     * This API will take a partially signed transaction and a set of public keys that the owner has the ability to sign for
     * and return the minimal subset of public keys that should add signatures to the transaction.
     *
     * @param transaction partially signed transaction
     * @param keys available owner public keys
     *
     * @return public keys that should add signatures
     */
    getRequiredSignatures(transaction: Transaction, keys: Address[]): Observable<Address[]>;
    /**
     * This method will return the set of all public keys that could possibly sign for a given transaction.
     * This call can be used by wallets to filter their set of public keys to just the relevant subset prior to calling get_required_signatures() to get the minimum subset.
     *
     * @param transaction unsigned transaction
     *
     * @return public keys that can sign transaction
     */
    getPotentialSignatures(transaction: Transaction): Observable<Address[]>;
    /**
     * Verifies required signatures of a transaction.
     *
     * @param transaction signed transaction to verify
     *
     * @return if the transaction has all of the required signatures
     */
    verifyAuthority(transaction: Transaction): Observable<boolean>;
    /**
     * Verifies if the signers have enough authority to authorize an account.
     *
     * @param nameOrId account name or object id
     * @param keys signer keys
     *
     * @return if the signers have enough authority
     */
    verifyAccountAuthority(nameOrId: string, keys: Address[]): Observable<boolean>;
    /**
     * Validates a transaction against the current state without broadcasting it on the network.
     *
     * @param transaction signed transaction
     *
     * @return {@link ProcessedTransaction} or fails with {@link DCoreError}
     */
    validateTransaction(transaction: Transaction): Observable<ProcessedTransaction>;
    /**
     * Returns fees for operation.
     *
     * @param op list of operations
     * @param assetId asset id eg. DCT id is 1.3.0
     *
     * @return a list of fee asset amounts
     */
    getFees(op: BaseOperation[], assetId?: ChainObject): Observable<AssetAmount[]>;
    /**
     * Returns fee for operation.
     *
     * @param op operation
     * @param assetId asset id eg. DCT id is 1.3.0
     *
     * @return a fee asset amount
     */
    getFee(op: BaseOperation, assetId: ChainObject): Observable<AssetAmount>;
    /**
     * Returns fee for operation type, not valid for operation per size fees:
     * {@link OperationType.ProposalCreate},
     * {@link OperationType.ProposalUpdate},
     * {@link OperationType.WithdrawPermissionClaim},
     * {@link OperationType.Custom}]
     *
     * @param op operation type
     * @param assetId asset id eg. DCT id is 1.3.0
     *
     * @return a fee asset amount
     */
    getFee(op: OperationType, assetId: ChainObject): Observable<AssetAmount>;
}
