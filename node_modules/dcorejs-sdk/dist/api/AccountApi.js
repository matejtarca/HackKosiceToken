"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var _ = require("lodash");
var rxjs_1 = require("rxjs");
var scalar_1 = require("rxjs/internal/observable/scalar");
var operators_1 = require("rxjs/operators");
var Credentials_1 = require("../crypto/Credentials");
var Account_1 = require("../models/Account");
var ChainObject_1 = require("../models/ChainObject");
var IllegalArgumentError_1 = require("../models/error/IllegalArgumentError");
var ObjectNotFoundError_1 = require("../models/error/ObjectNotFoundError");
var Memo_1 = require("../models/Memo");
var ObjectType_1 = require("../models/ObjectType");
var TransferOperation_1 = require("../models/operation/TransferOperation");
var SearchAccountsOrder_1 = require("../models/order/SearchAccountsOrder");
var GetAccountById_1 = require("../net/models/request/GetAccountById");
var GetAccountByName_1 = require("../net/models/request/GetAccountByName");
var GetAccountCount_1 = require("../net/models/request/GetAccountCount");
var GetAccountReferences_1 = require("../net/models/request/GetAccountReferences");
var GetFullAccounts_1 = require("../net/models/request/GetFullAccounts");
var GetKeyReferences_1 = require("../net/models/request/GetKeyReferences");
var LookupAccountNames_1 = require("../net/models/request/LookupAccountNames");
var LookupAccounts_1 = require("../net/models/request/LookupAccounts");
var SearchAccounts_1 = require("../net/models/request/SearchAccounts");
var ObjectCheckOf_1 = require("../utils/ObjectCheckOf");
var BaseApi_1 = require("./BaseApi");
var AccountApi = /** @class */ (function (_super) {
    __extends(AccountApi, _super);
    function AccountApi(api) {
        return _super.call(this, api) || this;
    }
    /**
     * Check if the account exist.
     *
     * @param account account id or name
     *
     * @return account exists in DCore database
     */
    AccountApi.prototype.exist = function (account) {
        return this.get(account).pipe(operators_1.catchError(function (err) {
            if (err instanceof ObjectNotFoundError_1.ObjectNotFoundError || err instanceof TypeError) {
                return rxjs_1.of(false);
            }
            else {
                return rxjs_1.throwError(err);
            }
        }), operators_1.mapTo(true));
    };
    /**
     * Get account object by name.
     *
     * @param name the name of the account
     *
     * @return an account if found, {@link ObjectNotFoundError} otherwise
     */
    AccountApi.prototype.getByName = function (name) {
        return this.request(new GetAccountByName_1.GetAccountByName(name));
    };
    /**
     * Get account by name or id.
     *
     * @param account account name or account id
     *
     * @return an account if exist, {@link ObjectNotFoundError} if not found, or {@link IllegalArgumentError} if the account name or id is not valid
     */
    AccountApi.prototype.get = function (account) {
        if (typeof account === "string") {
            if (ChainObject_1.ChainObject.isValid(account)) {
                return this.get(ChainObject_1.ChainObject.parse(account));
            }
            if (Account_1.Account.isValidName(account)) {
                return this.getByName(account);
            }
        }
        if (ObjectCheckOf_1.ObjectCheckOf(account, "instance")) {
            return this.getAll([account]).pipe(operators_1.map(function (list) { return list[0]; }));
        }
        return rxjs_1.throwError(new IllegalArgumentError_1.IllegalArgumentError("not a valid account name or id"));
    };
    /**
     * Get the total number of accounts registered on the blockchain.
     */
    AccountApi.prototype.countAll = function () {
        return this.request(new GetAccountCount_1.GetAccountCount());
    };
    /**
     * Get account object ids by public key addresses.
     *
     * @param keys formatted public keys of the account, eg. DCT5j2bMj7XVWLxUW7AXeMiYPambYFZfCcMroXDvbCfX1VoswcZG4
     *
     * @return a list of account object ids
     */
    AccountApi.prototype.findAllReferencesByKeys = function (keys) {
        return this.request(new GetKeyReferences_1.GetKeyReferences(keys));
    };
    /**
     * Get all accounts that refer to the account id in their owner or active authorities.
     *
     * @param accountId account object id
     *
     * @return a list of account object ids
     */
    AccountApi.prototype.findAllReferencesByAccount = function (accountId) {
        return this.request(new GetAccountReferences_1.GetAccountReferences(accountId));
    };
    /**
     * Get account objects by ids.
     *
     * @param accountIds object ids of the account, 1.2.*
     *
     * @return an account list if found, {@link ObjectNotFoundError} otherwise
     */
    AccountApi.prototype.getAll = function (accountIds) {
        return this.request(new GetAccountById_1.GetAccountById(accountIds));
    };
    /**
     * Fetch all objects relevant to the specified accounts and subscribe to updates.
     *
     * @param namesOrIds list of account names or ids
     * @param subscribe true to subscribe to updates
     *
     * @return map of names or ids to account, or empty map if not present
     */
    AccountApi.prototype.getFullAccounts = function (namesOrIds, subscribe) {
        if (subscribe === void 0) { subscribe = false; }
        return this.request(new GetFullAccounts_1.GetFullAccounts(namesOrIds, subscribe));
    };
    /**
     * Get a list of accounts by name.
     *
     * @param names account names to retrieve
     *
     * @return list of accounts or {@link ObjectNotFoundError} if none exist
     */
    AccountApi.prototype.getAllByNames = function (names) {
        return this.request(new LookupAccountNames_1.LookupAccountNames(names));
    };
    /**
     * Get names and IDs for registered accounts.
     *
     * @param lowerBound lower bound of the first name to return
     * @param limit number of items to get, max 1000
     *
     * @return map of account names to corresponding IDs
     */
    AccountApi.prototype.listAllRelative = function (lowerBound, limit) {
        if (limit === void 0) { limit = 1000; }
        return this.request(new LookupAccounts_1.LookupAccounts(lowerBound, limit));
    };
    /**
     * Get registered accounts that match search term.
     *
     * @param searchTerm will try to partially match account name or id
     * @param order sort data by field
     * @param id object id to start searching from
     * @param limit number of items to get, max 1000
     *
     * @return list of found accounts
     */
    AccountApi.prototype.findAll = function (searchTerm, order, id, limit) {
        if (order === void 0) { order = SearchAccountsOrder_1.SearchAccountsOrder.NameDesc; }
        if (id === void 0) { id = ObjectType_1.ObjectType.Null.genericId(); }
        if (limit === void 0) { limit = 1000; }
        return this.request(new SearchAccounts_1.SearchAccounts(searchTerm, order, id, limit));
    };
    /**
     * Create API credentials.
     *
     * @param accountName account name
     * @param privateKey private key in wif base58 format, eg. 5Jd7zdvxXYNdUfnEXt5XokrE3zwJSs734yQ36a1YaqioRTGGLtn
     *
     * @return credentials
     */
    AccountApi.prototype.createCredentials = function (accountName, privateKey) {
        return this.getByName(accountName).pipe(operators_1.map(function (acc) { return new Credentials_1.Credentials(acc.id, privateKey); }));
    };
    /**
     * Create a transfer operation.
     *
     * @param credentials account credentials
     * @param account account id or account name
     * @param amount amount to send with asset type
     * @param memo optional message
     * @param encrypted encrypted is visible only for sender and receiver, unencrypted is visible publicly
     * @param fee {@link AssetAmount} fee for the operation, if left undefined the fee will be computed in DCT asset
     *
     * @return a transaction confirmation
     */
    AccountApi.prototype.createTransfer = function (credentials, account, amount, memo, encrypted, fee) {
        if (encrypted === void 0) { encrypted = true; }
        if ((_.isNil(memo) || !encrypted) && (typeof account !== "string" || ChainObject_1.ChainObject.isValid(account))) {
            return scalar_1.scalar(new TransferOperation_1.TransferOperation(credentials.account, (typeof account === "string") ? ChainObject_1.ChainObject.parse(account) : account, amount, _.isNil(memo) ? memo : Memo_1.Memo.createPublic(memo), fee));
        }
        else {
            return this.get(account).pipe(operators_1.map(function (acc) { return new TransferOperation_1.TransferOperation(credentials.account, acc.id, amount, _.isNil(memo) ? memo : (encrypted ? Memo_1.Memo.createEncrypted(memo, credentials.keyPair, acc.primaryAddress) : Memo_1.Memo.createPublic(memo)), fee); }));
        }
    };
    /**
     * Make a transfer.
     *
     * @param credentials account credentials
     * @param account account id or account name
     * @param amount amount to send with asset type
     * @param memo optional message
     * @param encrypted encrypted is visible only for sender and receiver, unencrypted is visible publicly
     * @param fee {@link AssetAmount} fee for the operation, if left undefined the fee will be computed in DCT asset
     *
     * @return a transaction confirmation
     */
    AccountApi.prototype.transfer = function (credentials, account, amount, memo, encrypted, fee) {
        var _this = this;
        if (encrypted === void 0) { encrypted = true; }
        return this.createTransfer(credentials, account, amount, memo, encrypted, fee).pipe(operators_1.flatMap(function (operation) {
            return _this.api.broadcastApi.broadcastWithCallback(credentials.keyPair, [operation]);
        }));
    };
    return AccountApi;
}(BaseApi_1.BaseApi));
exports.AccountApi = AccountApi;
//# sourceMappingURL=AccountApi.js.map