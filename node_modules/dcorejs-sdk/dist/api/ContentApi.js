"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var _ = require("lodash");
var operators_1 = require("rxjs/operators");
var ChainObject_1 = require("../models/ChainObject");
var ContentTypes_1 = require("../models/ContentTypes");
var Memo_1 = require("../models/Memo");
var ObjectType_1 = require("../models/ObjectType");
var PurchaseContentOperation_1 = require("../models/operation/PurchaseContentOperation");
var TransferOperation_1 = require("../models/operation/TransferOperation");
var SearchContentOrder_1 = require("../models/order/SearchContentOrder");
var Regions_1 = require("../models/Regions");
var GenerateContentKeys_1 = require("../net/models/request/GenerateContentKeys");
var GetContentById_1 = require("../net/models/request/GetContentById");
var GetContentByUri_1 = require("../net/models/request/GetContentByUri");
var ListPublishingManagers_1 = require("../net/models/request/ListPublishingManagers");
var RestoreEncryptionKey_1 = require("../net/models/request/RestoreEncryptionKey");
var SearchContent_1 = require("../net/models/request/SearchContent");
var BaseApi_1 = require("./BaseApi");
var ContentApi = /** @class */ (function (_super) {
    __extends(ContentApi, _super);
    function ContentApi(api) {
        return _super.call(this, api) || this;
    }
    /**
     * Generate keys for new content submission.
     *
     * @param seeders list of seeder account IDs
     *
     * @return generated key and key parts
     */
    ContentApi.prototype.generateKeys = function (seeders) {
        return this.request(new GenerateContentKeys_1.GenerateContentKeys(seeders));
    };
    /**
     * Get content
     *
     * @param content uri of the content or object id of the content, 2.13.*
     *
     * @return a content if found, {@link ObjectNotFoundError} otherwise
     */
    ContentApi.prototype.get = function (content) {
        if (typeof content === "string" && ChainObject_1.ChainObject.isValid(content)) {
            return this.get(ChainObject_1.ChainObject.parse(content));
        }
        else if (typeof content === "string") {
            return this.request(new GetContentByUri_1.GetContentByUri(content));
        }
        else {
            return this.request(new GetContentById_1.GetContentById(content)).pipe(operators_1.map(function (list) { return list[0]; }));
        }
    };
    /**
     * Get a list of accounts holding publishing manager status.
     *
     * @param lowerBound the name of the first account to return. If the named account does not exist, the list will start at the account that comes after lowerbound
     * @param limit the maximum number of accounts to return (max: 100)
     *
     * @return a list of publishing managers
     */
    ContentApi.prototype.listAllPublishersRelative = function (lowerBound, limit) {
        if (limit === void 0) { limit = 100; }
        return this.request(new ListPublishingManagers_1.ListPublishingManagers(lowerBound, limit));
    };
    /**
     * Restores encryption key from key parts stored in buying object.
     *
     * @param elGamalPrivate the private El Gamal key
     * @param purchaseId the purchase object
     *
     * @return AES encryption key
     */
    ContentApi.prototype.restoreEncryptionKey = function (elGamalPrivate, purchaseId) {
        return this.request(new RestoreEncryptionKey_1.RestoreEncryptionKey(elGamalPrivate, purchaseId));
    };
    /**
     * Search for term in contents (author, title and description).
     *
     * @param term search term
     * @param order ordering field. Available options are defined in {@link SearchContentOrder}
     * @param user content owner account name
     * @param regionCode two letter region code, defined in [Regions]
     * @param type the application and content type to be filtered, use {@link contentType} method
     * @param startId the id of content object to start searching from
     * @param limit maximum number of contents to fetch (must not exceed 100)
     *
     * @return the contents found
     */
    ContentApi.prototype.findAll = function (term, order, user, regionCode, type, startId, limit) {
        if (order === void 0) { order = SearchContentOrder_1.SearchContentOrder.CreatedDesc; }
        if (user === void 0) { user = ""; }
        if (regionCode === void 0) { regionCode = Regions_1.REGION_NAMES[Regions_1.Regions.All]; }
        if (type === void 0) { type = ContentTypes_1.contentType(ContentTypes_1.ApplicationType.DecentCore, ContentTypes_1.CategoryType.None); }
        if (startId === void 0) { startId = ObjectType_1.ObjectType.Null.genericId(); }
        if (limit === void 0) { limit = 100; }
        return this.request(new SearchContent_1.SearchContent(term, order, user, regionCode, type, startId, limit));
    };
    /**
     * Create a purchase content operation.
     *
     * @param credentials account credentials
     * @param content uri of the content or object id of the content, 2.13.*
     */
    ContentApi.prototype.createPurchaseOperation = function (credentials, content) {
        return this.get(content).pipe(operators_1.map(function (c) { return PurchaseContentOperation_1.PurchaseContentOperation.create(credentials, c); }));
    };
    /**
     * Transfers an amount of one asset to content. Amount is transferred to author and co-authors of the content, if they are specified.
     * Fees are paid by the "from" account.
     *
     * @param credentials account credentials
     * @param id content id
     * @param amount amount to send with asset type
     * @param memo optional unencrypted message
     * @param fee {@link AssetAmount} fee for the operation, if left undefined the fee will be computed in DCT asset
     *
     * @return a transaction confirmation
     */
    ContentApi.prototype.createTransfer = function (credentials, id, amount, memo, fee) {
        return new TransferOperation_1.TransferOperation(credentials.account, id, amount, _.isNil(memo) ? memo : Memo_1.Memo.createPublic(memo), fee);
    };
    return ContentApi;
}(BaseApi_1.BaseApi));
exports.ContentApi = ContentApi;
//# sourceMappingURL=ContentApi.js.map