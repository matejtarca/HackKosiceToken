"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Crypto = require("crypto");
var _ = require("lodash/fp");
var secp256k1_1 = require("secp256k1");
var Utils_1 = require("../utils/Utils");
var Address_1 = require("./Address");
var Wif_1 = require("./Wif");
var ECKeyPair = /** @class */ (function () {
    /**
     * the public key is always in a compressed format in DCore
     */
    function ECKeyPair(privateKey) {
        this.privateKey = privateKey;
        this.publicKey = secp256k1_1.publicKeyCreate(this.privateKey, true);
    }
    ECKeyPair.parseWif = function (base58) {
        var data = Buffer.from(Utils_1.Utils.Base58.decode(base58));
        Utils_1.assertThrow(data.length > 4, function () { return "input too short"; });
        var checksum = data.slice(data.length - 4, data.length);
        data = data.slice(0, data.length - 4);
        Utils_1.assertThrow(data[0] === this.VERSION, function () { return data[0] + " is not a valid private key version byte"; });
        var actualChecksum = Utils_1.Utils.hashTwice256(data).slice(0, 4);
        Utils_1.assertThrow(_.isEqual(actualChecksum, checksum), function () { return "checksum not valid"; });
        // drop version byte
        data = data.slice(1, data.length);
        // check compressed byte and drop if true
        data = data.length === 33 && data[32] === 1 ? data.slice(0, data.length - 1) : data;
        return new ECKeyPair(data);
    };
    ECKeyPair.generate = function () {
        var random;
        do {
            random = Crypto.randomBytes(32);
        } while (!secp256k1_1.privateKeyVerify(random));
        return new ECKeyPair(random);
    };
    ECKeyPair.generateFromPhrase = function (phrase, sequence) {
        if (sequence === void 0) { sequence = 0; }
        var random;
        do {
            random = Utils_1.Utils.hash256(Utils_1.Utils.hash512(Buffer.from(phrase.toString() + " " + sequence)));
        } while (!secp256k1_1.privateKeyVerify(random));
        return new ECKeyPair(random);
    };
    Object.defineProperty(ECKeyPair.prototype, "publicAddress", {
        get: function () {
            return new Address_1.Address(this.publicKey);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ECKeyPair.prototype, "privateWif", {
        get: function () {
            return new Wif_1.Wif(this.privateKey, ECKeyPair.VERSION);
        },
        enumerable: true,
        configurable: true
    });
    ECKeyPair.prototype.sign = function (data) {
        var sig = secp256k1_1.sign(Utils_1.Utils.hash256(data), this.privateKey);
        var head = Buffer.alloc(1, sig.recovery + ECKeyPair.COMPRESSED + ECKeyPair.COMPACT);
        var sigData = Buffer.concat([head, sig.signature]);
        // tslint:disable:no-bitwise
        if ((sigData[0] & 0x80) !== 0 || sigData[0] === 0 ||
            (sigData[1] & 0x80) !== 0 ||
            (sigData[32] & 0x80) !== 0 || sigData[32] === 0 ||
            (sigData[33] & 0x80) !== 0) {
            return;
        }
        else {
            return sigData.toString("hex");
        }
    };
    ECKeyPair.prototype.secret = function (recipient, nonce) {
        var key = secp256k1_1.publicKeyTweakMul(recipient.publicKey, this.privateKey, true);
        return Utils_1.Utils.hash512(Buffer.from(nonce.toString() + Utils_1.Utils.hash512(key.slice(1)).toString("hex")));
    };
    ECKeyPair.VERSION = 0x80;
    ECKeyPair.COMPRESSED = 4;
    ECKeyPair.COMPACT = 27;
    return ECKeyPair;
}());
exports.ECKeyPair = ECKeyPair;
//# sourceMappingURL=ECKeyPair.js.map