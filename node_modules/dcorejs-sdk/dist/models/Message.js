"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _ = require("lodash");
var Long = require("long");
var Utils_1 = require("../utils/Utils");
var Message = /** @class */ (function () {
    function Message(operationId, timestamp, message, sender, receiver, senderAddress, receiverAddress, nonce) {
        if (nonce === void 0) { nonce = Long.ZERO; }
        this.operationId = operationId;
        this.timestamp = timestamp;
        this.message = message;
        this.sender = sender;
        this.receiver = receiver;
        this.senderAddress = senderAddress;
        this.receiverAddress = receiverAddress;
        this.nonce = nonce;
        this.encrypted = !!(this.senderAddress && this.receiverAddress);
    }
    Message.create = function (response) {
        return response.receiversData.map(function (rd) { return new Message(response.id, response.created, !!(response.senderAddress && rd.receiverAddress) ? rd.data : Buffer.from(rd.data, "hex").slice(4).toString("utf8"), response.sender, rd.receiver, response.senderAddress, rd.receiverAddress, rd.nonce); });
    };
    /**
     * Decrypt the message with given credentials
     *
     * @param credentials account credentials
     * @return decrypted message or unchanged message if unable to decrypt with credentials, check the [encrypted] field
     */
    Message.prototype.decrypt = function (credentials) {
        if (!this.encrypted) {
            return this;
        }
        Utils_1.assertThrow(!_.isNil(this.senderAddress));
        Utils_1.assertThrow(!_.isNil(this.receiverAddress));
        var decrypted = this.decryptOrNull(credentials.keyPair, credentials.account === this.sender ? this.receiverAddress : this.senderAddress);
        if (!_.isNil(decrypted)) {
            this.message = decrypted;
            this.encrypted = false;
        }
        return this;
    };
    Message.prototype.decryptOrNull = function (keyPair, address) {
        var secret = keyPair.secret(address, this.nonce);
        var clearText = Utils_1.Utils.decrypt(secret, Buffer.from(this.message, "hex"));
        var msg = clearText.slice(4);
        if (Utils_1.Utils.hash256(msg).slice(0, 4).equals(clearText.slice(0, 4))) {
            return msg.toString("utf8");
        }
        else {
            return;
        }
    };
    return Message;
}());
exports.Message = Message;
//# sourceMappingURL=Message.js.map