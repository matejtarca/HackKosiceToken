"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var BaseX = require("base-x");
var Crypto = require("crypto");
var crypto_1 = require("crypto");
var Long = require("long");
var moment = require("moment");
function assertThrow(value, lazyMessage) {
    if (lazyMessage === void 0) { lazyMessage = function () { return "assert error"; }; }
    if (!value) {
        throw TypeError(lazyMessage());
    }
}
exports.assertThrow = assertThrow;
var Utils = /** @class */ (function () {
    function Utils() {
    }
    Utils.generateNonce = function (power) {
        if (power === void 0) { power = 250; }
        return Long.fromString(Utils.generateEntropy(power).toString("hex"), true, 16);
    };
    Utils.generateEntropy = function (power) {
        if (power === void 0) { power = 250; }
        var input = Buffer.from(moment().toString());
        var entropy = Buffer.concat([
            Utils.hash256(input),
            Buffer.from(input.toString("binary")),
            Buffer.from(moment().toString()),
        ]);
        var start = moment().valueOf();
        while ((moment().valueOf() - start) < power) {
            entropy = Utils.hash256(entropy);
        }
        return Utils.hash256(Buffer.concat([entropy, Crypto.randomBytes(32)]));
    };
    Utils.hash256 = function (data) {
        return crypto_1.createHash("sha256").update(data).digest();
    };
    Utils.hash512 = function (data) {
        return crypto_1.createHash("sha512").update(data).digest();
    };
    Utils.hashTwice256 = function (data) {
        return this.hash256(this.hash256(data));
    };
    Utils.ripemd160 = function (data) {
        return crypto_1.createHash("ripemd160").update(data).digest();
    };
    Utils.encrypt = function (secret, data) {
        var cipher = Crypto.createCipheriv("aes-256-cbc", secret.slice(0, 32), secret.slice(32, 32 + 16));
        cipher.setAutoPadding(true);
        return Buffer.concat([cipher.update(data), cipher.final()]);
    };
    Utils.decrypt = function (secret, data) {
        var cipher = Crypto.createDecipheriv("aes-256-cbc", secret.slice(0, 32), secret.slice(32, 32 + 16));
        cipher.setAutoPadding(true);
        return Buffer.concat([cipher.update(data), cipher.final()]);
    };
    Utils.Base58 = BaseX("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
    return Utils;
}());
exports.Utils = Utils;
//# sourceMappingURL=Utils.js.map